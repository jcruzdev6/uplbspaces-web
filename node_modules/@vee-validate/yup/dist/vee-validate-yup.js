/**
  * vee-validate v4.11.1
  * (c) 2023 Abdelrahman Awad
  * @license MIT
  */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.VeeValidateYup = {}));
})(this, (function (exports) { 'use strict';

    function toTypedSchema(yupSchema, opts = { abortEarly: false }) {
        const schema = {
            __type: 'VVTypedSchema',
            async parse(values) {
                var _a;
                try {
                    // we spread the options because yup mutates the opts object passed
                    const output = await yupSchema.validate(values, Object.assign({}, opts));
                    return {
                        value: output,
                        errors: [],
                    };
                }
                catch (err) {
                    const error = err;
                    // Yup errors have a name prop one them.
                    // https://github.com/jquense/yup#validationerrorerrors-string--arraystring-value-any-path-string
                    if (error.name !== 'ValidationError') {
                        throw err;
                    }
                    if (!((_a = error.inner) === null || _a === void 0 ? void 0 : _a.length) && error.errors.length) {
                        return { errors: [{ path: error.path, errors: error.errors }] };
                    }
                    const errors = error.inner.reduce((acc, curr) => {
                        const path = curr.path || '';
                        if (!acc[path]) {
                            acc[path] = { errors: [], path };
                        }
                        acc[path].errors.push(...curr.errors);
                        return acc;
                    }, {});
                    // list of aggregated errors
                    return { errors: Object.values(errors) };
                }
            },
            cast(values) {
                try {
                    return yupSchema.cast(values);
                }
                catch (_a) {
                    return values;
                }
            },
        };
        return schema;
    }

    exports.toTypedSchema = toTypedSchema;

}));
