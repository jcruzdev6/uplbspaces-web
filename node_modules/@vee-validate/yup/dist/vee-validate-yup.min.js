/**
  * vee-validate v4.11.1
  * (c) 2023 Abdelrahman Awad
  * @license MIT
  */
!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?r(exports):"function"==typeof define&&define.amd?define(["exports"],r):r((e="undefined"!=typeof globalThis?globalThis:e||self).VeeValidateYup={})}(this,(function(e){"use strict";e.toTypedSchema=function(e,r={abortEarly:!1}){return{__type:"VVTypedSchema",async parse(t){var n;try{return{value:await e.validate(t,Object.assign({},r)),errors:[]}}catch(e){const r=e;if("ValidationError"!==r.name)throw e;if(!(null===(n=r.inner)||void 0===n?void 0:n.length)&&r.errors.length)return{errors:[{path:r.path,errors:r.errors}]};const t=r.inner.reduce(((e,r)=>{const t=r.path||"";return e[t]||(e[t]={errors:[],path:t}),e[t].errors.push(...r.errors),e}),{});return{errors:Object.values(t)}}},cast(r){try{return e.cast(r)}catch(e){return r}}}}}));